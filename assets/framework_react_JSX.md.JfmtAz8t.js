import{_ as e,c as t,o as a,a4 as r}from"./chunks/framework.CFdyflnk.js";const S=JSON.parse('{"title":"JSX","description":"","frontmatter":{},"headers":[],"relativePath":"framework/react/JSX.md","filePath":"framework/react/JSX.md","lastUpdated":1726577403000}'),s={name:"framework/react/JSX.md"},i=r('<h1 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h1><p><em>JSX</em> stands for JavaScript XML. It is a syntax extension to JavaScript.</p><h3 id="why-jsx" tabindex="-1"><strong>Why JSX?</strong> <a class="header-anchor" href="#why-jsx" aria-label="Permalink to &quot;**Why JSX?**&quot;">​</a></h3><p>关注点分离：不是直接分离html，css，js文件，而是逻辑关联的“组件”，实现某个组件的html，css，js都放在同一个文件。最主要的还是html和js的融合，css通常不使用行内样式。</p><h3 id="基本语法" tabindex="-1">基本语法 <a class="header-anchor" href="#基本语法" aria-label="Permalink to &quot;基本语法&quot;">​</a></h3><ul><li>在HTML中写JavaScript，表达式写在{}里面</li><li>JSX代码本身是一段表达式，可以当做<strong>右值</strong></li><li>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。</li><li>组件化使用 jsx 而不是模板</li><li>规则： <ul><li>只能有一个根元素，可以用根标签 &lt;&gt;...&lt;/&gt;</li><li>标签必须闭合</li><li>小写字母开头，则认为是元素，大写字母开头，则认为是组件</li><li>className={} onClick={} style={</li></ul></li><li>JSX 防止注入攻击（<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="nofollow noopener noreferrer">XSS (cross-site-scripting)</a>）：React DOM 在渲染所有输入内容之前，默认会进行<a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="nofollow noopener noreferrer">转义</a>。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="nofollow noopener noreferrer">XSS（cross-site-scripting, 跨站脚本）</a>攻击。</li></ul>',6),o=[i];function l(n,c,h,p,_,d){return a(),t("div",null,o)}const m=e(s,[["render",l]]);export{S as __pageData,m as default};
