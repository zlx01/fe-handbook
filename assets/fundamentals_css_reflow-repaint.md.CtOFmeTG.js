import{_ as e,c as l,o as i,ag as t}from"./chunks/framework.C86mscM5.js";const p=JSON.parse('{"title":"Reflow vs Repaint","description":"","frontmatter":{},"headers":[],"relativePath":"fundamentals/css/reflow-repaint.md","filePath":"fundamentals/css/reflow-repaint.md","lastUpdated":1744516180000}'),r={name:"fundamentals/css/reflow-repaint.md"};function o(n,a,s,d,h,c){return i(),l("div",null,a[0]||(a[0]=[t('<h1 id="reflow-vs-repaint" tabindex="-1">Reflow vs Repaint <a class="header-anchor" href="#reflow-vs-repaint" aria-label="Permalink to &quot;Reflow vs Repaint&quot;">​</a></h1><h2 id="重排-reflow" tabindex="-1">重排（reflow） <a class="header-anchor" href="#重排-reflow" aria-label="Permalink to &quot;重排（reflow）&quot;">​</a></h2><p>当网页的内容或结构发生变化时，浏览器需要重新计算元素的位置、大小等布局信息。任何改变会引起整个文档的重新布局，这个过程称为重排。</p><h2 id="重绘-repaint" tabindex="-1">重绘（repaint） <a class="header-anchor" href="#重绘-repaint" aria-label="Permalink to &quot;重绘（repaint）&quot;">​</a></h2><p>指当元素的外观发生变化（但没有改变其布局时），浏览器会重新绘制这些元素的样式</p><h2 id="引起重排的原因" tabindex="-1">引起重排的原因 <a class="header-anchor" href="#引起重排的原因" aria-label="Permalink to &quot;引起重排的原因&quot;">​</a></h2><ul><li>改变元素的大小（如 width, height, margin, padding, border 等）。</li><li>添加或删除 DOM 元素。</li><li>改变字体大小或内容（例如插入文本）。</li><li>获取某些属性（如 offsetWidth, offsetHeight, clientWidth, scrollTop 等），因为这些属性会触发浏览器去计算当前的布局。</li></ul><h2 id="引起重绘的原因" tabindex="-1">引起重绘的原因 <a class="header-anchor" href="#引起重绘的原因" aria-label="Permalink to &quot;引起重绘的原因&quot;">​</a></h2><ul><li>改变元素的颜色（如 color, background-color）。</li><li>改变可见性（如 visibility: hidden，但不包括 display: none，因为 display: none 会引发重排）。</li><li>改变边框颜色或样式。</li></ul><h2 id="比较" tabindex="-1">比较 <a class="header-anchor" href="#比较" aria-label="Permalink to &quot;比较&quot;">​</a></h2><ul><li>重排⼀定重绘，重绘不⼀定重排</li><li>重排性能开销较大</li><li>重绘性能开销较小</li></ul><h2 id="减少重绘和重排的方法" tabindex="-1">减少重绘和重排的⽅法 <a class="header-anchor" href="#减少重绘和重排的方法" aria-label="Permalink to &quot;减少重绘和重排的⽅法&quot;">​</a></h2><ul><li>合并和减少 DOM 操作</li><li>避免逐个修改样式</li><li>合并样式变更</li><li>减少布局抖动（Layout Thrashing）</li><li>使用 CSS3 动画（硬件加速）通过 GPU 进行加速</li><li>使用 will-change 优化复杂动画。浏览器哪些元素的属性即将发生变化，浏览器会提前优化这些元素的渲染。它适用于需要优化性能的场景，但不要过度使用，因为它会占用更多内存。</li><li>使用 requestAnimationFrame</li><li>避免触发同步布局事件，例如获取 offsetWidth, scrollTop, clientHeight 等属性</li><li>优化复杂页面的渲染：虚拟滚动、分页加载内容</li></ul>',13)]))}const u=e(r,[["render",o]]);export{p as __pageData,u as default};
