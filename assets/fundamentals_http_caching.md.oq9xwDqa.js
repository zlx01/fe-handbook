import{_ as o,c as t,o as a,ag as r}from"./chunks/framework.C86mscM5.js";const c="/fe-handbook/assets/image.DfwCQocK.webp",f=JSON.parse('{"title":"HTTP Caching","description":"","frontmatter":{},"headers":[],"relativePath":"fundamentals/http/caching.md","filePath":"fundamentals/http/caching.md","lastUpdated":1744516180000}'),n={name:"fundamentals/http/caching.md"};function p(l,e,i,s,h,d){return a(),t("div",null,e[0]||(e[0]=[r('<h1 id="http-caching" tabindex="-1">HTTP Caching <a class="header-anchor" href="#http-caching" aria-label="Permalink to &quot;HTTP Caching&quot;">​</a></h1><ul><li>强缓存 Strong cache</li><li>协商缓存 Negotiation cache</li></ul><blockquote><p>HTTP协议中规定使用GMT时间，也就是格林威治标准时间，而我们国家使用的是GMT+8时区，所以在HTTP头信息中的时间会比我们的正常时间早8个小时，但它一点都不影响HTTP缓存的正常工作。</p></blockquote><h2 id="缓存获取顺序" tabindex="-1">缓存获取顺序 <a class="header-anchor" href="#缓存获取顺序" aria-label="Permalink to &quot;缓存获取顺序&quot;">​</a></h2><blockquote><p>按照缓存顺序来讲，当一个资源准备加载时，浏览器会根据其<strong>三级缓存原理</strong>进行判断。</p><ol><li>浏览器会率先查找内存缓存，如果资源在内存中存在，那么直接从内存中加载</li><li>如果内存中没找到，接下去会去磁盘中查找，找到便从磁盘中获取</li><li>如果磁盘中也没有找到，那么就进行网络请求，并将请求后符合条件的资源存入内存和磁盘中</li></ol><p>浏览器内存缓存生效的前提下，JS 资源的执行加载时间会影响其是否被内存缓存</p><p>图片资源（非 base64）也有和 JS 资源同样的现象，而 CSS 资源比较与众不同，其被磁盘缓存的概率远大于被内存缓存。</p><p>当使用 preload 预加载资源后，笔者发现该资源一直会从磁盘缓存中读取，JS、CSS 及图片资源都有同样的表现，这主要还是和资源的渲染时机有关，在渲染机制还没有介入前的资源加载不会被内存缓存。</p><p>prefetch 则表示预提取，告诉浏览器加载下一页面可能会用到的资源，浏览器会利用空闲状态进行下载并将资源存储到缓存中。</p><p>比如：访问图片-&gt; 200 -&gt; 退出浏览器</p><p>再进来-&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache)</p><p>我们可以打开一个新的tab页面，打开 &quot;Network&quot;，刷新一下，看到缓存的 <code>.js</code> 都是 &quot;from memory&quot;（<code>.css</code> 不会走 memory cache，都是 &quot;from disk&quot;）。</p><p>现在我们关闭当前tab（或关闭浏览器），重新再打开之前的 tab 时，缓存的 <code>.js</code> 都是 &quot;from disk&quot; 了。</p><p>因为当 <code>.js</code> 等资源被加载时，浏览器会先将其放入 <code>memory cache</code> 中，而当此页面tab被关闭时，浏览器会将此页面的 <code>memory cache</code> 中的缓存文件转存到 <code>disk cache</code> 中持久化存储。</p></blockquote><p><a href="https://nuxtjs-v316.vercel.app/" target="_blank" rel="nofollow noopener noreferrer">https://nuxtjs-v316.vercel.app/</a></p><p><img src="'+c+'" alt="image"></p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><p><a href="https://segmentfault.com/a/1190000007729685" target="_blank" rel="nofollow noopener noreferrer">https://segmentfault.com/a/1190000007729685</a></p></li><li><p><a href="https://blog.devgenius.io/web-application-performance-optimization-http-caching-791eeda4509e" target="_blank" rel="nofollow noopener noreferrer">https://blog.devgenius.io/web-application-performance-optimization-http-caching-791eeda4509e</a></p></li><li><p><a href="https://juejin.cn/post/7177568033316012088" target="_blank" rel="nofollow noopener noreferrer">https://juejin.cn/post/7177568033316012088</a></p></li><li><p><a href="https://www.cnblogs.com/developer-ios/p/14044834.html" target="_blank" rel="nofollow noopener noreferrer">https://www.cnblogs.com/developer-ios/p/14044834.html</a></p></li></ul>',9)]))}const g=o(n,[["render",p]]);export{f as __pageData,g as default};
