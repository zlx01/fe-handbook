import{_ as e,c as t,o as a,a4 as i}from"./chunks/framework.luo6lmAI.js";const f=JSON.parse('{"title":"Thinking in React","description":"","frontmatter":{},"headers":[],"relativePath":"framework/react/thinking-in-react.md","filePath":"framework/react/thinking-in-react.md","lastUpdated":1713631529000}'),r={name:"framework/react/thinking-in-react.md"},o=i('<h1 id="thinking-in-react" tabindex="-1">Thinking in React <a class="header-anchor" href="#thinking-in-react" aria-label="Permalink to &quot;Thinking in React&quot;">​</a></h1><p><a href="https://react.dev/learn/thinking-in-react" target="_blank" rel="nofollow noopener noreferrer">Thinking in React – React</a></p><h2 id="step-0-start-with-the-mockup" tabindex="-1">Step 0: Start with the mockup <a class="header-anchor" href="#step-0-start-with-the-mockup" aria-label="Permalink to &quot;Step 0: Start with the mockup&quot;">​</a></h2><p>先准备好mock数据和设计稿（交互/视觉）</p><h2 id="step-1-break-the-ui-into-a-component-hierarchy" tabindex="-1">Step 1: Break the UI into a component hierarchy <a class="header-anchor" href="#step-1-break-the-ui-into-a-component-hierarchy" aria-label="Permalink to &quot;Step 1: Break the UI into a component hierarchy&quot;">​</a></h2><p>拆分组件层级结构</p><p>划分依据：</p><ul><li>单一职责</li><li>设计稿元素的层次、交互</li><li>复用程度</li><li>页面 or 布局 or 组件</li><li><s>有无状态</s></li></ul><h2 id="step-2-build-a-static-version-in-react" tabindex="-1">Step 2: Build a static version in React <a class="header-anchor" href="#step-2-build-a-static-version-in-react" aria-label="Permalink to &quot;Step 2: Build a static version in React&quot;">​</a></h2><p>先做视觉还原，不care数据流和交互</p><h2 id="step-3-find-the-minimal-but-complete-representation-of-ui-state" tabindex="-1">Step 3: Find the minimal but complete representation of UI state <a class="header-anchor" href="#step-3-find-the-minimal-but-complete-representation-of-ui-state" aria-label="Permalink to &quot;Step 3: Find the minimal but complete representation of UI state&quot;">​</a></h2><p>确定应用的状态</p><blockquote><p>Think of state as the minimal set of changing data that your app needs to remember.</p></blockquote><p>注意区分props和state，可以计算的数据也不是state</p><h2 id="step-4-identify-where-your-state-should-live" tabindex="-1">Step 4: Identify where your state should live <a class="header-anchor" href="#step-4-identify-where-your-state-should-live" aria-label="Permalink to &quot;Step 4: Identify where your state should live&quot;">​</a></h2><blockquote><p>React uses one-way data flow, passing data down the component hierarchy from parent to child component.</p></blockquote><p>确定状态应该归属哪个组件。通常是确定组件依赖的state，找到共同的祖先组件，放在祖先组件中。</p><h2 id="step-5-add-inverse-data-flow" tabindex="-1">Step 5: Add inverse data flow <a class="header-anchor" href="#step-5-add-inverse-data-flow" aria-label="Permalink to &quot;Step 5: Add inverse data flow&quot;">​</a></h2><p>通常是父组件传进来的set方法设置父组件的state</p><h2 id="以tic-tac-toe为例" tabindex="-1">以tic-tac-toe为例 <a class="header-anchor" href="#以tic-tac-toe为例" aria-label="Permalink to &quot;以tic-tac-toe为例&quot;">​</a></h2><h3 id="_0-start-with-the-mockup" tabindex="-1">0.Start with the mockup <a class="header-anchor" href="#_0-start-with-the-mockup" aria-label="Permalink to &quot;0.Start with the mockup&quot;">​</a></h3><p>初始数据为空，无须mockUI；比较简单：一个棋盘九个格子，○或×</p><h3 id="_1-break-the-ui-into-a-component-hierarchy" tabindex="-1">1.Break the UI into a component hierarchy <a class="header-anchor" href="#_1-break-the-ui-into-a-component-hierarchy" aria-label="Permalink to &quot;1.Break the UI into a component hierarchy&quot;">​</a></h3><ul><li>游戏zujian</li><li>棋盘组件</li><li>格子组件</li></ul><h3 id="_2-build-a-static-version-in-react" tabindex="-1">2.Build a static version in React <a class="header-anchor" href="#_2-build-a-static-version-in-react" aria-label="Permalink to &quot;2.Build a static version in React&quot;">​</a></h3><ul><li>flex布局或grid布局都可以搞定</li></ul><h3 id="_3-find-the-minimal-but-complete-representation-of-ui-state" tabindex="-1">3.Find the minimal but complete representation of UI state <a class="header-anchor" href="#_3-find-the-minimal-but-complete-representation-of-ui-state" aria-label="Permalink to &quot;3.Find the minimal but complete representation of UI state&quot;">​</a></h3><ul><li>棋盘九个格子的状态，可以用一个数组表示</li><li>历史记录，可以用一个二维数组表示</li><li>下一个落子是哪一方。可以简单用一个布尔变量表示，但考虑到可以回退到历史记录的某一步，可以用一个状态表示当前是第几步，用模2取余来决定哪一方下一个落子。</li><li>当前是第几步</li></ul><h3 id="_4-identify-where-your-state-should-live" tabindex="-1">4.Identify where your state should live <a class="header-anchor" href="#_4-identify-where-your-state-should-live" aria-label="Permalink to &quot;4.Identify where your state should live&quot;">​</a></h3><ul><li>格子组件：每个单元格的数据来自父组件</li><li>棋盘组件：数据来自游戏组件，监听子组件的点击事件，并处理“谁赢”的逻辑</li><li>游戏组件：所有状态数据</li></ul><h3 id="_5-add-inverse-data-flow" tabindex="-1">5.Add inverse data flow <a class="header-anchor" href="#_5-add-inverse-data-flow" aria-label="Permalink to &quot;5.Add inverse data flow&quot;">​</a></h3><ul><li>点击空格事件 → 判断输赢 → 更新棋盘数据 → 更新历史数据</li><li>回退历史点击事件 → 更新棋盘数据</li></ul>',32),n=[o];function l(h,s,c,d,p,u){return a(),t("div",null,n)}const k=e(r,[["render",l]]);export{f as __pageData,k as default};
