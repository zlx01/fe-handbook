import{_ as s,c as a,o as e,a4 as i}from"./chunks/framework.CFdyflnk.js";const g=JSON.parse('{"title":"Vue Loader","description":"","frontmatter":{},"headers":[],"relativePath":"framework/vue/v2/vue-loader/index.md","filePath":"framework/vue/v2/vue-loader/index.md","lastUpdated":1726577403000}'),l={name:"framework/vue/v2/vue-loader/index.md"},t=i(`<h1 id="vue-loader" tabindex="-1">Vue Loader <a class="header-anchor" href="#vue-loader" aria-label="Permalink to &quot;Vue Loader&quot;">​</a></h1><blockquote><p>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件</p></blockquote><p>下面记录开发经常使用的</p><h2 id="处理资源路径" tabindex="-1">处理资源路径 <a class="header-anchor" href="#处理资源路径" aria-label="Permalink to &quot;处理资源路径&quot;">​</a></h2><p>当 Vue Loader 编译单文件组件中的 &lt;template&gt; &lt;style&gt;块时，它也会将所有遇到的资源 URL 转换为 <strong>webpack 模块请求</strong>。内部使用了两个loader：</p><ul><li>file-loader 可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存。此外，这意味着 你可以就近管理图片文件，可以使用相对路径而不用担心部署时 URL 的问题。使用正确的配置，webpack 将会在打包输出中自动重写文件路径为正确的 URL。</li><li>url-loader 允许你有条件地将文件转换为内联的 base-64 URL (当文件小于给定的阈值)，这会减少小文件的 HTTP 请求数。如果文件大于该阈值，会自动的交给 file-loader 处理。</li></ul><h2 id="css预处理器" tabindex="-1">css预处理器 <a class="header-anchor" href="#css预处理器" aria-label="Permalink to &quot;css预处理器&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Sass</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sass-loader</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node-sass</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Less</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> less-loader</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> less</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Stylus</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stylus-loader</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stylus</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> postcss-loader</span></span></code></pre></div><h2 id="scoped-css" tabindex="-1">Scoped CSS <a class="header-anchor" href="#scoped-css" aria-label="Permalink to &quot;Scoped CSS&quot;">​</a></h2><ul><li><p>通过PostCSS转换，原来的选择器会复合属性选择器[data-v-uid]</p></li><li><p>优先选择类选择器或id选择器</p></li><li><p>混用本地和全局样式：在一个组件中同时使用有 scoped 和非 scoped 样式</p></li><li><p>子组件的根元素：使用 scoped 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。</p></li><li><p>深度作用选择器</p><ul><li>stylus的样式穿透 使用 &gt;&gt;&gt;</li><li>sass、scss和less的样式穿透 使用 /deep/</li><li>sass、scss和less的样式穿透 使用 ::v-deep</li><li>/deep/ ::v-deep 都是&gt;&gt;&gt;的别名</li></ul></li><li><p>动态生成的内容：通过 v-html 创建的 DOM 内容不受 scoped 样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。</p></li><li><p>在递归组件中小心使用后代选择器! 对选择器 .a .b 中的 CSS 规则来说，如果匹配 .a 的元素包含一个递归子组件，则所有的子组件中的 .b 都将被这个规则匹配</p></li></ul><h2 id="vue-单文件组件-sfc-规范" tabindex="-1">Vue 单文件组件 (SFC) 规范 <a class="header-anchor" href="#vue-单文件组件-sfc-规范" aria-label="Permalink to &quot;Vue 单文件组件 (SFC) 规范&quot;">​</a></h2><h3 id="模板" tabindex="-1">模板 <a class="header-anchor" href="#模板" aria-label="Permalink to &quot;模板&quot;">​</a></h3><ul><li>每个 <code>.vue</code> 文件最多包含一个 <code>&lt;template&gt;</code> 块。</li><li>内容将被提取并传递给 <code>vue-template-compiler</code> 为字符串，预处理为 JavaScript 渲染函数，并最终注入到从 <code>&lt;script&gt;</code> 导出的组件中。</li></ul><h3 id="脚本" tabindex="-1">脚本 <a class="header-anchor" href="#脚本" aria-label="Permalink to &quot;脚本&quot;">​</a></h3><ul><li>每个 <code>.vue</code> 文件最多包含一个 <code>&lt;script&gt;</code> 块。</li><li>这个脚本会作为一个 ES Module 来执行。</li><li>它的<strong>默认导出</strong>应该是一个 Vue.js 的<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE" target="_blank" rel="nofollow noopener noreferrer">组件选项对象</a>。也可以导出由 <code>Vue.extend()</code> 创建的扩展对象，但是普通对象是更好的选择。</li><li>任何匹配 <code>.js</code> 文件 (或通过它的 <code>lang</code> 特性指定的扩展名) 的 webpack 规则都将会运用到这个 <code>&lt;script&gt;</code> 块的内容中。</li></ul><h3 id="样式" tabindex="-1">样式 <a class="header-anchor" href="#样式" aria-label="Permalink to &quot;样式&quot;">​</a></h3><ul><li>默认匹配：<code>/\\.css$/</code>。</li><li>一个 <code>.vue</code> 文件可以包含多个 <code>&lt;style&gt;</code> 标签。</li><li><code>&lt;style&gt;</code> 标签可以有 scoped 或者 module 属性。</li><li>任何匹配 <code>.css</code> 文件 (或通过它的 <code>lang</code> 特性指定的扩展名) 的 webpack 规则都将会运用到这个 <code>&lt;style&gt;</code> 块的内容中。</li></ul>`,17),n=[t];function o(d,p,r,c,h,k){return e(),a("div",null,n)}const F=s(l,[["render",o]]);export{g as __pageData,F as default};
